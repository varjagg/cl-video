(in-package :cl-video)

(define-constant  +pcmi-uncompressed+ 1)

(define-condition unsupported-wav-file-format (media-decoder-error)
  ()
  (:report (lambda (condition stream)
	     (declare (ignorable condition))
	     (format stream "Unsupported WAV file format"))))

(define-condition malformed-wav-file-format (media-decoder-error)
  ()
  (:report (lambda (condition stream)
	     (declare (ignorable condition))
	     (format stream "Malformed WAV file format"))))

(defclass wav-stream-record (stream-record)
  ((fcc-type :accessor fcc-type)
   (fcc-handler :accessor fcc-handler)
   (flags :accessor flags)
   (priority :accessor priority)
   (language :accessor language)
   (initial-frames :accessor initial-frames)
   (scale :accessor scale)
   (rate :accessor rate)
   (start :accessor start)
   (stream-length :accessor stream-length)
   (suggested-buffer-size :accessor suggested-buffer-size)
   (quality :accessor quality)
   (sample-size :accessor sample-size)
   (frame :accessor frame)
   (frame-delay :accessor frame-delay :initarg :frame-delay)
   (index :accessor index)))

(defmethod stream-playback-start ((rec wav-stream-record))
  (sleep (* (start rec) (/ (scale rec) (rate rec)))) ;stream delay, if any
  (call-next-method))

(defclass audio-stream-record (wav-stream-record)
  ((compression-code :accessor compression-code)
   (number-of-channels :accessor number-of-channels)
   (sample-rate :accessor sample-rate)
   (average-bytes-per-second :accessor average-bytes-per-second)
   (block-align :accessor block-align)
   (significant-bits-per-sample :accessor significant-bits-per-sample)
   (extra-format-bytes :accessor extra-format-bytes)
   (extra-bytes :accessor extra-bytes)))

(defmethod shared-initialize :after ((rec audio-stream-record) slots &key &allow-other-keys)
  (declare (ignorable slots))
  (setf  (buffer rec) (make-array (suggested-buffer-size rec) :element-type '(unsigned-byte 8))))

(defmethod read-audio-stream-header ((rec audio-stream-record) stream)
  (loop for chunk = (riff:read-riff-chunk stream)
     when (string-equal (riff:riff-chunk-id chunk) "strf") do
       (flexi-streams:with-input-from-sequence (is (riff:riff-chunk-data chunk))
	(setf (compression-code rec) (riff:read-u2 is)
	     (number-of-channels rec) (riff:read-u2 is)
	     (sample-rate rec) (riff:read-u4 is)
	     (average-bytes-per-second rec) (riff:read-u4 is)
	     (block-align rec) (riff:read-u2 is)
	     (significant-bits-per-sample rec) (riff:read-u2 is))
	(debug-log (format nil "Audio stream with sample rate ~D at ~D bits per sample" (sample-rate rec) (significant-bits-per-sample rec)))
       (unless (eql (compression-code rec) +pcmi-uncompressed+)
	 (setf (extra-format-bytes rec) (riff:read-u2 is)
	       (extra-bytes rec) (make-array (extra-format-bytes rec) :element-type (stream-element-type is)))
	 (read-sequence (extra-bytes rec) is)))
       (return)))

(defmethod decode-media-stream ((rec audio-stream-record) fsize input-stream)
  (let* ((chunk (pop (wcursor rec)))
	 (cur-lock (vacancy-lock chunk))
	 (new-chunk (car (wcursor rec))))
    (bt:acquire-lock (vacancy-lock new-chunk))
    (read-sequence (frame chunk) input-stream :end fsize)
    (bt:release-lock cur-lock)))

(defclass wav-container (av-container)
  ())

(defmethod initialize-instance :after ((s wav-container) &key &allow-other-keys)
  (setf (chunk-decoder s) #'(lambda (stream id size)
			      (if (member (subseq id 2) '("dc" "wb") :test #'string-equal)
				  (progn (decode-media-stream (elt (stream-records s) (parse-integer (subseq id 0 2))) size stream)
					 (when (plusp (padding s)) (loop repeat (rem size (padding s)) do (read-byte s))))
				  (read-sequence (make-array size :element-type '(unsigned-byte 8)) stream)))))

(defmethod read-wav-stream-info ((wav wav-container) stream)
  (loop for chunk = (riff:read-riff-chunk stream)
     with rec = (make-instance 'wav-stream-record :container wav)
     when (string-equal (riff:riff-chunk-id chunk) "strh") do
       (flexi-streams:with-input-from-sequence (is (riff:riff-chunk-data chunk))
	 (setf (fcc-type rec) (riff::read-fourcc is)
	       (fcc-handler rec) (riff::read-fourcc is)
	       (flags rec) (riff:read-u4 is)
	       (priority rec) (riff:read-u2 is)
	       (language rec) (riff:read-u2 is)
	       (initial-frames rec) (riff:read-u4 is)
	       (scale rec) (riff:read-u4 is)
	       (rate rec) (riff:read-u4 is)
	       (start rec) (riff:read-u4 is)
	       (stream-length rec) (riff:read-u4 is)
	       (suggested-buffer-size rec) (riff:read-u4 is)
	       (quality rec) (riff:read-u4 is)
	       (sample-size rec) (riff:read-u4 is)
	       (frame rec) (list (riff:read-u2 is) (riff:read-u2 is) (riff:read-u2 is) (riff:read-u2 is))))
       (when (and (string-equal (fcc-type rec) "vids") (not (member (fcc-handler rec) '("mjpg") :test #'string-equal)))
	 (error 'unsupported-wav-file-format))
       (cond ((and (string-equal (fcc-type rec) "vids") (string-equal (fcc-handler rec) "mjpg"))
	      (change-class rec 'mjpeg-stream-record) (setf (frame-delay rec) (/ (scale rec) (rate rec))))
	     ((string-equal (fcc-type rec) "auds")
	      (change-class rec 'audio-stream-record) (read-audio-stream-header rec stream) (setf (frame-delay rec) (/ (scale rec) (rate rec)))))
       (return-from read-wav-stream-info rec))
  (error 'malformed-wav-file-format))

(defmethod read-wav-header ((wav wav-container) stream)
  (loop for chunk = (riff:read-riff-chunk stream)
     when (string-equal (riff:riff-chunk-id chunk) "wavh") do
       (flexi-streams:with-input-from-sequence (is (riff:riff-chunk-data chunk))
	 (riff:read-u4 is)   ;;dwMicroSecPerFrame
	 (riff:read-u4 is)   ;;dwMaxBytesPerSec
	 (setf (padding wav) (riff:read-u4 is)
	       (flags wav) (riff:read-u4 is))
	 (riff:read-u4 is)   ;;dwTotalFrames
	 (riff:read-u4 is)   ;;dwInitialFrames
	 (setf (nstreams wav) (riff:read-u4 is))
	 (riff:read-u4 is) ;;dwSuggestedBufferSize
	 (setf (width wav) (riff:read-u4 is)
	       (height wav) (riff:read-u4 is))
	 (riff:read-u4 is) (riff:read-u4 is) (riff:read-u4 is) (riff:read-u4 is))
       (setf (stream-records wav)
	     (loop repeat (nstreams wav) collecting (read-wav-stream-info wav stream)))
       (return)))

(defmethod find-pcm-stream-record ((container av-container))
  nil)

(defmethod find-pcm-stream-record ((wav wav-container))
  (find-if #'(lambda (x) (and (eql (type-of x) 'audio-stream-record)
			      (eql (compression-code x) +pcmi-uncompressed+))) (stream-records wav)))

(defmethod decode ((wav wav-container))
  (with-open-file (stream (filename wav) :direction :input :element-type '(unsigned-byte 8))
    ;; read WAV header first
    (let* ((chunk (riff:read-riff-chunk stream))
	   (id (getf chunk :chunk-id))
	   (fourcc (getf chunk :file-type)))
      (unless (string-equal id "riff")
	(error 'unrecognized-file-format))
      (cond ((string-equal fourcc "wav ") (read-wav-header wav stream))
	    (t (error 'unsupported-wav-file-format))))
    (when (player-callback wav)
      (funcall (player-callback wav) wav))
    (loop for chunk = (riff:read-riff-chunk stream :chunk-data-reader (chunk-decoder wav))
       while (and chunk (not (finish wav))))
    (loop for rec in (stream-records wav) do 
	 (setf (final rec) (car (wcursor rec)))
	 (bt:release-lock (vacancy-lock (car (wcursor rec)))))))

(defun show-file-chunks (pathname)
  (with-open-file (stream pathname :direction :input :element-type '(unsigned-byte 8))
    (loop for chunk = (riff:read-riff-chunk stream)
	 while chunk do (format t "~A size ~D~%" (riff:riff-chunk-id chunk) (riff:riff-chunk-data-size chunk)))))
